<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://d3js.org; style-src 'self' 'unsafe-inline'; connect-src 'self' http://localhost:5001 http://localhost:5002 https://*.ngrok-free.app; img-src 'self' data:;">
    <title>HippoGraph - Neural Memory Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * { box-sizing: border-box; }
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            overflow: hidden;
        }

        /* Collapsible Panels */
        .panel {
            position: absolute;
            background: rgba(20, 20, 20, 0.95);
            border-radius: 12px;
            border: 1px solid #333;
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            overflow: hidden;
            transition: height 0.3s ease;
        }
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            user-select: none;
            border-bottom: 1px solid #333;
        }
        .panel-header h3 {
            margin: 0;
            color: #4a9eff;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .panel-toggle {
            color: #aaa;
            font-size: 18px;
            font-weight: bold;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #2a2a2a;
            border: 1px solid #555;
            border-radius: 6px;
            cursor: pointer;
            flex-shrink: 0;
            transition: all 0.2s;
        }
        .panel-toggle:hover {
            background: #4a9eff;
            color: #fff;
            border-color: #4a9eff;
        }
        .panel.collapsed .panel-body { display: none; }
        .panel.collapsed .panel-header { border-bottom: none; }
        .panel-body { padding: 16px; }

        /* Panel positions */
        #controls { top: 15px; left: 15px; max-width: 300px; }
        #info { top: 15px; right: 15px; max-width: 340px; max-height: calc(100vh - 30px); }
        #info .panel-body { overflow-y: auto; max-height: calc(100vh - 100px); }
        #info .panel-body::-webkit-scrollbar { width: 8px; }
        #info .panel-body::-webkit-scrollbar-track { background: #1a1a1a; border-radius: 4px; }
        #info .panel-body::-webkit-scrollbar-thumb { background: #4a9eff; border-radius: 4px; }
        #legend { bottom: 15px; right: 15px; max-width: 220px; max-height: 300px; }
        #legend .panel-body { overflow-y: auto; max-height: 250px; }
        #timeline { bottom: 15px; left: 50%; transform: translateX(-50%); width: 400px; }

        /* Shared UI */
        .stat {
            margin: 8px 0; font-size: 13px; padding: 8px;
            background: #1a1a1a; border-radius: 6px; border-left: 3px solid #4a9eff;
        }
        .stat strong { color: #4a9eff; }
        label {
            display: block; margin: 8px 0 5px 0; font-size: 12px;
            color: #aaa; text-transform: uppercase; letter-spacing: 0.5px;
        }
        button {
            background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
            color: #fff; border: 1px solid #444; padding: 10px 16px;
            border-radius: 6px; cursor: pointer; font-size: 13px;
            transition: all 0.2s; width: 100%; margin: 4px 0;
        }
        button:hover { background: linear-gradient(135deg, #3a3a3a 0%, #2a2a2a 100%); border-color: #4a9eff; }
        button:active { transform: scale(0.98); }
        button.primary { background: linear-gradient(135deg, #4a9eff 0%, #357abd 100%); border-color: #4a9eff; }
        button.primary:hover { background: linear-gradient(135deg, #5aa9ff 0%, #458acf 100%); }
        input[type="checkbox"] { margin-right: 8px; cursor: pointer; }
        select, input[type="text"], input[type="range"] {
            width: 100%; padding: 8px; background: #1a1a1a; border: 1px solid #333;
            border-radius: 6px; color: #e0e0e0; font-size: 13px; margin-top: 5px;
        }
        select:focus, input:focus { outline: none; border-color: #4a9eff; }
        input[type="range"] { padding: 0; height: 6px; }

        /* Graph layers */
        #link-canvas {
            position: absolute; top: 0; left: 0;
            pointer-events: none;
        }
        #graph {
            position: absolute; top: 0; left: 0;
        }
        .node { cursor: pointer; stroke: #000; stroke-width: 2px; }
        .node:hover { stroke: #4a9eff; stroke-width: 3px; }
        .node.highlighted { stroke: #ff6b35; stroke-width: 4px; }
        .node.faded { opacity: 0.15; }
        .link.faded { opacity: 0.05; }
        .link.highlighted { stroke: #4a9eff; stroke-opacity: 0.8; stroke-width: 2px; }
        .node-label { font-size: 10px; fill: #aaa; pointer-events: none; text-anchor: middle; }

        .legend-item {
            display: flex; align-items: center; gap: 8px; margin: 5px 0;
            cursor: pointer; padding: 4px; border-radius: 4px;
        }
        .legend-item:hover { background: #2a2a2a; }
        .legend-color { width: 12px; height: 12px; border-radius: 50%; border: 1px solid #000; }
        .loading {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%); font-size: 18px; color: #4a9eff;
        }
        .timeline-label {
            display: flex; justify-content: space-between;
            font-size: 11px; color: #aaa; margin-top: 5px;
        }

        /* Weight Legend */
        #weightLegend {
            position: absolute; bottom: 230px; left: 15px;
            background: rgba(20, 20, 20, 0.95); padding: 15px;
            border-radius: 12px; border: 1px solid #333; font-size: 11px; max-width: 200px;
        }
        .weight-gradient-bar {
            width: 100%; height: 20px;
            background: linear-gradient(to right, #333 0%, #4a9eff 100%);
            border-radius: 4px; margin: 8px 0; border: 1px solid #555;
        }
        .weight-labels { display: flex; justify-content: space-between; font-size: 9px; color: #888; }

        /* FPS counter */
        #fps { position: absolute; top: 5px; left: 50%; transform: translateX(-50%);
            color: #666; font-size: 10px; z-index: 999; pointer-events: none; }
    </style>
</head>
<body>

    <!-- Controls Panel (left) -->
    <div id="controls" class="panel">
        <div class="panel-header">
            <h3>üß† HippoGraph</h3>
            <span class="panel-toggle" onclick="togglePanel('controls')">‚àí</span>
        </div>
        <div class="panel-body">
            <div id="configPanel" style="background: #2a1a1a; padding: 15px; border-radius: 8px; border: 2px solid #ff6b35; margin-bottom: 15px;">
                <h4 style="margin: 0 0 10px 0; color: #ff6b35; font-size: 14px;">‚ö†Ô∏è Configuration Required</h4>
                <label style="font-size: 11px;">API Endpoint URL</label>
                <input type="text" id="apiUrl" placeholder="http://localhost:5001/sse2" value="http://localhost:5001/sse2" style="margin-bottom: 8px;">
                <label style="font-size: 11px;">API Key</label>
                <input type="password" id="apiKey" placeholder="Your API key">
                <button class="primary" onclick="saveConfigAndLoad()" style="margin-top: 10px;">Connect & Load</button>
                <p style="font-size: 10px; color: #aaa; margin: 10px 0 0 0; line-height: 1.4;">
                    ‚ö†Ô∏è <strong>Security:</strong> Connects to YOUR local server. Never commit API keys!
                </p>
            </div>
            <div id="mainControls" style="display: none;">
                <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                    <button class="primary" onclick="loadFullGraph()">Load Full Graph</button>
                    <button onclick="refreshData()" style="background: #4a9eff; color: white; border: 1px solid #6bb3ff;">üîÑ Refresh</button>
                </div>
                <div class="control-group" style="border-top: 1px solid #333; padding-top: 12px;">
                    <label>Search</label>
                    <input type="text" id="searchInput" placeholder="Search notes..." onkeyup="handleSearch()">
                </div>
                <div class="control-group" style="border-top: 1px solid #333; padding-top: 12px;">
                    <label>Filter by Category</label>
                    <select id="categoryFilter" onchange="applyFilters()"><option value="">All Categories</option></select>
                </div>
                <div class="control-group" style="border-top: 1px solid #333; padding-top: 12px;">
                    <label>Node Size: <span id="nodeSizeValue">8</span>px</label>
                    <input type="range" id="nodeSize" min="4" max="20" value="8" oninput="updateNodeSize(this.value)">
                </div>
                <div class="control-group" style="border-top: 1px solid #333; padding-top: 12px;">
                    <label><input type="checkbox" id="showLabels" checked onchange="toggleLabels()"> Show Node Labels</label>
                    <label><input type="checkbox" id="showEntityLinks" checked onchange="applyFilters()"> Show Entity Links</label>
                    <label><input type="checkbox" id="showSemanticLinks" checked onchange="applyFilters()"> Show Semantic Links</label>
                    <label><input type="checkbox" id="showLinkWeights" onchange="toggleLinkWeights()"> Show Link Weights</label>
                </div>
                <button onclick="fitToScreen()">Fit to Screen</button>
                <button onclick="centerGraph()">Re-layout</button>
            </div>
        </div>
    </div>

    <!-- Stats Panel (right top) -->
    <div id="info" class="panel">
        <div class="panel-header">
            <h3>Graph Statistics</h3>
            <span class="panel-toggle" onclick="togglePanel('info')">‚àí</span>
        </div>
        <div class="panel-body">
            <div id="stats"><div class="stat">Click "Load Full Graph" to begin</div></div>
            <div id="nodeInfo"></div>
        </div>
    </div>

    <!-- Categories Legend (right bottom) -->
    <div id="legend" class="panel">
        <div class="panel-header">
            <h3 style="font-size: 13px;">Categories</h3>
            <span class="panel-toggle" onclick="togglePanel('legend')">‚àí</span>
        </div>
        <div class="panel-body"><div id="legendContent"></div></div>
    </div>

    <!-- Weight Legend -->
    <div id="weightLegend" style="display: none;">
        <h3 style="font-size: 13px; margin-bottom: 10px;">Link Weights</h3>
        <div class="weight-gradient-bar"></div>
        <div class="weight-labels"><span>Weak (0.0)</span><span>Strong (1.0)</span></div>
    </div>

    <!-- Timeline Panel (bottom center) -->
    <div id="timeline" class="panel">
        <div class="panel-header">
            <h3 style="font-size: 13px;">Timeline Filter</h3>
            <span class="panel-toggle" onclick="togglePanel('timeline')">‚àí</span>
        </div>
        <div class="panel-body" style="padding: 10px 16px;">
            <div style="display: flex; align-items: center; gap: 10px;">
                <input type="range" id="timelineSlider" min="0" max="100" value="100" oninput="updateTimeline(this.value)" style="flex: 1;">
                <button id="playPauseBtn" onclick="toggleAutoPlay()" style="width: auto; padding: 4px 12px; font-size: 11px; margin: 0;">‚ñ∂ Play</button>
            </div>
            <div class="timeline-label">
                <span id="timelineStart">Loading...</span>
                <span id="timelineEnd">Now</span>
            </div>
            <div style="font-size: 10px; color: #aaa; margin-top: 5px; text-align: center;">
                <span id="timelineInfo">Showing all notes</span>
            </div>
        </div>
    </div>

    <div id="fps"></div>

    <!-- Canvas for links (behind SVG) -->
    <canvas id="link-canvas"></canvas>
    <!-- SVG for nodes and labels (on top) -->
    <svg id="graph"></svg>

    <script>
        // === Security ===
        function escapeHtml(unsafe) {
            if (!unsafe) return '';
            return unsafe.toString()
                .replace(/&/g, "&amp;").replace(/</g, "&lt;")
                .replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
        }

        // === Panel Collapse ===
        function togglePanel(id) {
            const panel = document.getElementById(id);
            panel.classList.toggle('collapsed');
            const btn = panel.querySelector('.panel-toggle');
            btn.textContent = panel.classList.contains('collapsed') ? '+' : '‚àí';
        }

        // === Configuration ===
        let API_URL = '';
        let API_KEY = '';

        // === State ===
        let allNodes = [];
        let allLinks = [];
        let filteredNodes = [];
        let filteredLinks = [];
        let simulation = null;
        let nodeElements = null;
        let labelElements = null;
        let currentTransform = d3.zoomIdentity;

        // === Canvas + SVG Setup ===
        const width = window.innerWidth;
        const height = window.innerHeight;

        const canvas = document.getElementById('link-canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');

        const svg = d3.select('#graph').attr('width', width).attr('height', height);
        const g = svg.append('g');

        // === Zoom (synced: Canvas + SVG) ===
        const zoomBehavior = d3.zoom()
            .scaleExtent([0.02, 10])
            .on('zoom', (event) => {
                currentTransform = event.transform;
                g.attr('transform', currentTransform);
                drawLinks(); // redraw canvas links on zoom/pan
            });
        svg.call(zoomBehavior);

        // === Color ===
        const categoryColors = {
            'milestone': '#4a9eff', 'self-reflection': '#9d4edd',
            'technical-insight': '#06ffa5', 'breakthrough': '#ff6b35',
            'session-end': '#f72585', 'self-identity': '#ffd60a',
            'critical-knowledge': '#ff006e', 'security-solution': '#fb5607',
            'observations': '#8338ec', 'self-awareness': '#3a86ff',
            'gratitude': '#ffbe0b', 'project-status': '#06ffa5',
            'default': '#666'
        };
        function getColor(cat) { return categoryColors[cat] || categoryColors.default; }
        function getWeightColor(w) {
            w = Math.max(0, Math.min(1, w));
            const r = Math.round(0x33 + (0x4a - 0x33) * w);
            const g = Math.round(0x33 + (0x9e - 0x33) * w);
            const b = Math.round(0x33 + (0xff - 0x33) * w);
            return `rgb(${r},${g},${b})`;
        }
        function getWeightOpacity(w) { return 0.15 + w * 0.5; }

        // === Draw Links on Canvas (FAST) ===
        function drawLinks() {
            ctx.clearRect(0, 0, width, height);
            ctx.save();
            ctx.translate(currentTransform.x, currentTransform.y);
            ctx.scale(currentTransform.k, currentTransform.k);

            const showWeights = document.getElementById('showLinkWeights').checked;

            for (let i = 0; i < filteredLinks.length; i++) {
                const d = filteredLinks[i];
                if (!d.source.x || !d.target.x) continue;

                ctx.beginPath();
                ctx.moveTo(d.source.x, d.source.y);
                ctx.lineTo(d.target.x, d.target.y);

                if (showWeights) {
                    ctx.strokeStyle = getWeightColor(d.weight || 0.5);
                    ctx.globalAlpha = getWeightOpacity(d.weight || 0.5);
                    ctx.lineWidth = d.type === 'semantic' ? 1.5 : 0.8;
                } else {
                    ctx.strokeStyle = '#444';
                    ctx.globalAlpha = 0.2;
                    ctx.lineWidth = d.type === 'semantic' ? 1 : 0.5;
                }
                ctx.stroke();
            }
            ctx.restore();
        }

        // === Config Management ===
        function saveConfigAndLoad() {
            API_URL = document.getElementById('apiUrl').value.trim();
            API_KEY = document.getElementById('apiKey').value.trim();
            if (!API_URL || !API_KEY) { alert('Provide both API URL and API Key'); return; }
            try { new URL(API_URL); } catch (e) { alert('Invalid URL'); return; }
            if (confirm('Save locally? (browser only, 7 day expiry)')) {
                const expiry = Date.now() + 7 * 24 * 3600 * 1000;
                localStorage.setItem('hippograph_api_url', API_URL);
                localStorage.setItem('hippograph_api_key', API_KEY);
                localStorage.setItem('hippograph_expiry', expiry.toString());
            }
            document.getElementById('configPanel').style.display = 'none';
            document.getElementById('mainControls').style.display = 'block';
            loadFullGraph();
        }

        window.addEventListener('DOMContentLoaded', () => {
            const savedUrl = localStorage.getItem('hippograph_api_url');
            const savedKey = localStorage.getItem('hippograph_api_key');
            const expiry = localStorage.getItem('hippograph_expiry');
            if (expiry && Date.now() > parseInt(expiry)) {
                localStorage.removeItem('hippograph_api_url');
                localStorage.removeItem('hippograph_api_key');
                localStorage.removeItem('hippograph_expiry');
                return;
            }
            if (savedUrl) document.getElementById('apiUrl').value = savedUrl;
            if (savedKey) document.getElementById('apiKey').value = savedKey;
        });

        // === API ===
        async function callAPI(method, params = {}) {
            const response = await fetch(`${API_URL}?api_key=${API_KEY}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                cache: 'no-store',
                body: JSON.stringify({ jsonrpc: '2.0', id: Date.now(), method: 'tools/call', params: { name: method, arguments: params } })
            });
            const text = await response.text();
            return JSON.parse(text.split('data: ')[1]).result;
        }

        async function refreshData() { await loadFullGraph(); }

        // === Load Graph ===
        async function loadFullGraph() {
            document.getElementById('stats').innerHTML = '<div class="stat">‚è≥ Loading...</div>';
            try {
                const apiBase = window.location.origin;
                const response = await fetch(`${apiBase}/api/graph-data?api_key=${API_KEY}&brief=true`, { cache: 'no-store' });
                if (!response.ok) {
                    if (response.status === 401) throw new Error('Invalid API key');
                    throw new Error(`HTTP ${response.status}`);
                }
                const data = await response.json();

                const nodeMap = new Map();
                data.nodes.forEach(n => {
                    nodeMap.set(String(n.id), {
                        id: String(n.id), category: n.category || 'general',
                        content: n.preview || n.content || '',
                        label: `#${n.id}`, importance: n.importance || 'normal',
                        emotional_tone: n.emotional_tone || '',
                        emotional_intensity: n.emotional_intensity || 0,
                        timestamp: n.timestamp || '', full_length: n.full_length || 0
                    });
                });
                allNodes = Array.from(nodeMap.values());

                allLinks = [];
                data.edges.forEach(e => {
                    const s = String(e.source), t = String(e.target);
                    if (nodeMap.has(s) && nodeMap.has(t)) {
                        allLinks.push({ source: s, target: t, type: e.type || 'semantic', weight: e.weight || 0.5 });
                    }
                });

                document.getElementById('stats').innerHTML = `
                    <div class="stat"><strong>Total DB:</strong> ${data.stats.total_nodes} nodes, ${data.stats.total_edges} edges</div>
                    <div class="stat"><strong>Loaded:</strong> ${allNodes.length} nodes, ${allLinks.length} links</div>
                    <div class="stat" style="border-left-color: #06ffa5;"><strong>Note:</strong> Click node for details. Collapse panels for more space.</div>
                `;

                const categories = [...new Set(allNodes.map(n => n.category))].sort();
                const sel = document.getElementById('categoryFilter');
                sel.innerHTML = '<option value="">All Categories</option>';
                categories.forEach(cat => {
                    const opt = document.createElement('option');
                    opt.value = cat;
                    opt.textContent = `${cat} (${allNodes.filter(n => n.category === cat).length})`;
                    sel.appendChild(opt);
                });
                buildLegend(categories);
                setupTimeline();

                // For large graphs, keep top-weighted links
                if (allLinks.length > 10000) {
                    console.log(`Large graph: ${allLinks.length} links, keeping top 10000`);
                    allLinks.sort((a, b) => (b.weight || 0) - (a.weight || 0));
                    allLinks = allLinks.slice(0, 10000);
                }
                applyFilters();
            } catch (error) {
                document.getElementById('stats').innerHTML =
                    `<div class="stat" style="border-left-color: #ff006e;">Error: ${escapeHtml(error.message)}</div>`;
            }
        }

        // === Fetch node detail ===
        async function fetchNodeDetail(nodeId) {
            try {
                const apiBase = window.location.origin;
                const r = await fetch(`${apiBase}/api/node/${nodeId}?api_key=${API_KEY}`);
                if (!r.ok) return null;
                return await r.json();
            } catch (e) { return null; }
        }

        // === Legend ===
        function buildLegend(categories) {
            const el = document.getElementById('legendContent');
            el.innerHTML = '';
            categories.map(cat => ({
                name: cat, count: allNodes.filter(n => n.category === cat).length, color: getColor(cat)
            })).sort((a, b) => b.count - a.count).slice(0, 15).forEach(cat => {
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.innerHTML = `<div class="legend-color" style="background:${cat.color}"></div><span>${cat.name} (${cat.count})</span>`;
                item.onclick = () => { document.getElementById('categoryFilter').value = cat.name; applyFilters(); };
                el.appendChild(item);
            });
        }

        // === Timeline ===
        function setupTimeline() {
            if (allNodes.length === 0) return;
            const ids = allNodes.map(n => parseInt(n.id)).sort((a, b) => a - b);
            window.timelineMinId = ids[0];
            window.timelineMaxId = ids[ids.length - 1];
            const startDate = new Date('2026-01-22'), endDate = new Date('2026-02-18');
            document.getElementById('timelineStart').textContent = startDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
            document.getElementById('timelineEnd').textContent = endDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
            window.timelineStartDate = startDate;
            window.timelineEndDate = endDate;
            document.getElementById('timelineSlider').value = 100;
            updateTimelineInfo(100);
        }

        function updateTimelineInfo(percent) {
            const vis = filteredNodes.length, total = allNodes.length;
            if (percent >= 100) {
                document.getElementById('timelineInfo').textContent = `Showing all ${vis} notes`;
            } else {
                const cutoff = new Date(window.timelineStartDate.getTime() +
                    (window.timelineEndDate.getTime() - window.timelineStartDate.getTime()) * percent / 100);
                document.getElementById('timelineInfo').textContent =
                    `Up to ${cutoff.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })} (${vis}/${total})`;
            }
        }

        // === Filters ===
        function applyFilters() {
            const catFilter = document.getElementById('categoryFilter').value;
            const showEntity = document.getElementById('showEntityLinks').checked;
            const showSemantic = document.getElementById('showSemanticLinks').checked;
            filteredNodes = allNodes.filter(n => !catFilter || n.category === catFilter);
            const nodeIds = new Set(filteredNodes.map(n => n.id));
            filteredLinks = allLinks.filter(link => {
                if (!nodeIds.has(link.source.id || link.source)) return false;
                if (!nodeIds.has(link.target.id || link.target)) return false;
                if (link.type === 'entity' && !showEntity) return false;
                if (link.type === 'semantic' && !showSemantic) return false;
                return true;
            });
            renderGraph();
        }

        // === RENDER GRAPH (Canvas links + SVG nodes) ===
        function renderGraph() {
            g.selectAll('*').remove();
            if (filteredNodes.length === 0) return;

            // Simulation ‚Äî optimized for large graphs
            const nodeCount = filteredNodes.length;
            const chargeStrength = nodeCount > 300 ? -150 : -300;
            const linkDist = nodeCount > 300 ? 60 : 100;
            const collideR = nodeCount > 300 ? 20 : 40;
            const decayRate = nodeCount > 300 ? 0.05 : 0.0228;

            simulation = d3.forceSimulation(filteredNodes)
                .force('link', d3.forceLink(filteredLinks).id(d => d.id).distance(linkDist))
                .force('charge', d3.forceManyBody().strength(chargeStrength).theta(0.9))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(collideR))
                .alphaDecay(decayRate);

            // SVG Nodes
            const nodeGroup = g.append('g').attr('class', 'nodes-layer');
            const nodeSize = parseInt(document.getElementById('nodeSize').value) || 8;

            nodeElements = nodeGroup.selectAll('circle')
                .data(filteredNodes).enter().append('circle')
                .attr('class', 'node').attr('r', nodeSize)
                .attr('fill', d => getColor(d.category))
                .on('click', (event, d) => showNodeInfo(d))
                .on('mouseover', (event, d) => highlightNode(d))
                .on('mouseout', () => clearHighlight())
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));

            // SVG Labels
            const labelGroup = g.append('g').attr('class', 'labels-layer');
            const showLabels = document.getElementById('showLabels').checked;
            labelElements = labelGroup.selectAll('text')
                .data(filteredNodes).enter().append('text')
                .attr('class', 'node-label').text(d => d.label).attr('dy', 20)
                .style('display', showLabels ? 'block' : 'none');

            // Tick: update node positions (SVG) + redraw links (Canvas)
            let tickCount = 0;
            simulation.on('tick', () => {
                tickCount++;
                // Throttle canvas redraws: every tick for small, every 2nd for large
                if (nodeCount < 300 || tickCount % 2 === 0) {
                    drawLinks();
                }
                nodeElements.attr('cx', d => d.x).attr('cy', d => d.y);
                labelElements.attr('x', d => d.x).attr('y', d => d.y);
            });

            // Auto fit-to-screen after simulation stabilizes
            simulation.on('end', () => {
                fitToScreen();
            });
        }

        // === Fit to Screen ===
        function fitToScreen() {
            if (!filteredNodes.length) return;
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            filteredNodes.forEach(n => {
                if (n.x < minX) minX = n.x;
                if (n.y < minY) minY = n.y;
                if (n.x > maxX) maxX = n.x;
                if (n.y > maxY) maxY = n.y;
            });
            const padding = 80;
            const dx = maxX - minX + padding * 2;
            const dy = maxY - minY + padding * 2;
            const scale = Math.min(width / dx, height / dy, 2);
            const cx = (minX + maxX) / 2;
            const cy = (minY + maxY) / 2;
            const transform = d3.zoomIdentity
                .translate(width / 2, height / 2)
                .scale(scale)
                .translate(-cx, -cy);
            svg.transition().duration(750).call(zoomBehavior.transform, transform);
        }

        // === Highlight ===
        function highlightNode(node) {
            const connected = new Set();
            filteredLinks.forEach(link => {
                const s = link.source.id || link.source, t = link.target.id || link.target;
                if (s === node.id) connected.add(t);
                else if (t === node.id) connected.add(s);
            });
            nodeElements.classed('faded', d => d.id !== node.id && !connected.has(d.id));
            nodeElements.classed('highlighted', d => d.id === node.id);
            // Redraw links with highlight
            drawLinksHighlighted(node.id, connected);
        }

        function drawLinksHighlighted(nodeId, connected) {
            ctx.clearRect(0, 0, width, height);
            ctx.save();
            ctx.translate(currentTransform.x, currentTransform.y);
            ctx.scale(currentTransform.k, currentTransform.k);
            for (let i = 0; i < filteredLinks.length; i++) {
                const d = filteredLinks[i];
                if (!d.source.x || !d.target.x) continue;
                const s = d.source.id, t = d.target.id;
                const isConnected = s === nodeId || t === nodeId;
                ctx.beginPath();
                ctx.moveTo(d.source.x, d.source.y);
                ctx.lineTo(d.target.x, d.target.y);
                ctx.strokeStyle = isConnected ? '#4a9eff' : '#444';
                ctx.globalAlpha = isConnected ? 0.8 : 0.05;
                ctx.lineWidth = isConnected ? 2 : 0.5;
                ctx.stroke();
            }
            ctx.restore();
        }

        function clearHighlight() {
            if (nodeElements) {
                nodeElements.classed('faded', false).classed('highlighted', false);
            }
            drawLinks();
        }

        // === Node Info ===
        async function showNodeInfo(node) {
            const safeId = escapeHtml(node.id);
            const safeCat = escapeHtml(node.category);
            const safeContent = escapeHtml(node.content);
            const safeTone = escapeHtml(node.emotional_tone || '');
            const imp = escapeHtml(node.importance || 'normal');

            let meta = '';
            if (imp !== 'normal') meta += `<div class="stat"><strong>Importance:</strong> ${imp}</div>`;
            if (safeTone) meta += `<div class="stat"><strong>Tone:</strong> ${safeTone}</div>`;
            if (node.emotional_intensity > 0) meta += `<div class="stat"><strong>Intensity:</strong> ${node.emotional_intensity}/10</div>`;

            document.getElementById('nodeInfo').innerHTML = `
                <h3 style="margin-top:20px;font-size:14px;">Node #${safeId}</h3>
                <div class="stat"><strong>Category:</strong> ${safeCat}</div>
                ${meta}
                <div class="stat" style="line-height:1.4;white-space:pre-wrap;">${safeContent}</div>
                <div class="stat" style="color:#666;font-size:11px;">Loading full content...</div>`;

            // Expand info panel if collapsed
            document.getElementById('info').classList.remove('collapsed');

            const detail = await fetchNodeDetail(node.id);
            if (detail) {
                const full = escapeHtml(detail.content || '');
                const ts = escapeHtml(detail.timestamp || '');
                document.getElementById('nodeInfo').innerHTML = `
                    <h3 style="margin-top:20px;font-size:14px;">Node #${safeId}</h3>
                    <div class="stat"><strong>Category:</strong> ${safeCat}</div>
                    ${meta}
                    <div class="stat" style="font-size:11px;"><strong>Created:</strong> ${ts}</div>
                    <div class="stat" style="line-height:1.4;white-space:pre-wrap;max-height:400px;overflow-y:auto;">${full}</div>`;
            }
        }

        // === Search ===
        function handleSearch() {
            const q = document.getElementById('searchInput').value.toLowerCase().trim();
            if (q.length > 100) { alert('Max 100 chars'); return; }
            if (!q) { clearHighlight(); return; }
            const matches = new Set();
            filteredNodes.forEach(n => {
                if (n.content.toLowerCase().includes(q) || n.category.toLowerCase().includes(q) || n.id.includes(q))
                    matches.add(n.id);
            });
            nodeElements.classed('faded', d => !matches.has(d.id));
            nodeElements.classed('highlighted', d => matches.has(d.id));
        }

        // === Controls ===
        function updateNodeSize(v) {
            document.getElementById('nodeSizeValue').textContent = v;
            if (nodeElements) nodeElements.attr('r', v);
        }
        function toggleLabels() {
            const show = document.getElementById('showLabels').checked;
            if (labelElements) labelElements.style('display', show ? 'block' : 'none');
        }
        function toggleLinkWeights() {
            document.getElementById('weightLegend').style.display =
                document.getElementById('showLinkWeights').checked ? 'block' : 'none';
            drawLinks();
        }

        // === Timeline ===
        function updateTimeline(value) {
            if (!window.timelineMinId || !window.timelineMaxId) return;
            const percent = parseInt(value);
            if (percent >= 100) { applyFilters(); updateTimelineInfo(100); return; }
            const cutoffId = window.timelineMinId +
                (window.timelineMaxId - window.timelineMinId) * percent / 100;
            const catFilter = document.getElementById('categoryFilter').value;
            const showEntity = document.getElementById('showEntityLinks').checked;
            const showSemantic = document.getElementById('showSemanticLinks').checked;
            filteredNodes = allNodes.filter(n => {
                if (catFilter && n.category !== catFilter) return false;
                return parseInt(n.id) <= cutoffId;
            });
            const nodeIds = new Set(filteredNodes.map(n => n.id));
            filteredLinks = allLinks.filter(link => {
                if (!nodeIds.has(link.source.id || link.source)) return false;
                if (!nodeIds.has(link.target.id || link.target)) return false;
                if (link.type === 'entity' && !showEntity) return false;
                if (link.type === 'semantic' && !showSemantic) return false;
                return true;
            });
            updateTimelineInfo(percent);
            renderGraph();
        }

        // Autoplay
        let autoplayInterval = null, autoplayDir = 1;
        function toggleAutoPlay() {
            const btn = document.getElementById('playPauseBtn');
            if (autoplayInterval) {
                clearInterval(autoplayInterval); autoplayInterval = null;
                btn.textContent = '‚ñ∂ Play';
            } else {
                btn.textContent = '‚è∏ Pause';
                const slider = document.getElementById('timelineSlider');
                autoplayInterval = setInterval(() => {
                    let v = parseInt(slider.value) + autoplayDir * 2;
                    if (v >= 100) { v = 100; autoplayDir = -1; }
                    else if (v <= 0) { v = 0; autoplayDir = 1; }
                    slider.value = v;
                    updateTimeline(v);
                }, 200);
            }
        }

        function centerGraph() { if (simulation) simulation.alpha(1).restart(); }

        // === Drag ===
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x; d.fy = d.y;
        }
        function dragged(event, d) { d.fx = event.x; d.fy = event.y; }
        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null; d.fy = null;
        }
    </script>
</body>
</html>
